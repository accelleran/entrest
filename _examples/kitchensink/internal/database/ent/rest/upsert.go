// Code generated by ent, DO NOT EDIT.

package rest

import (
	"context"
	"time"

	github "github.com/google/go-github/v66/github"
	uuid "github.com/google/uuid"
	"github.com/lrstanley/entrest/_examples/kitchensink/internal/database/ent"
	"github.com/lrstanley/entrest/_examples/kitchensink/internal/database/ent/category"
	"github.com/lrstanley/entrest/_examples/kitchensink/internal/database/ent/user"
	schema "github.com/lrstanley/entrest/_examples/kitchensink/internal/database/schema"
)

// UpsertCategoryParams defines parameters for upserting a Category via a PUT request.
// Only includes fields/edges not excluded from upsert operations.
// Upsert performs partial updates: only provided fields are updated, unprovided optional fields retain their existing values.
type UpsertCategoryParams struct {
	Name     string   `json:"name"`
	Nillable *string  `json:"nillable"`
	Strings  []string `json:"strings,omitempty"`
	Ints     []int    `json:"ints,omitempty"`
	Pets     []int    `json:"pets,omitempty"`
}

func (u *UpsertCategoryParams) ApplyInputs(builder *ent.CategoryCreate) *ent.CategoryCreate {
	builder.SetName(u.Name)
	if u.Nillable != nil {
		builder.SetNillable(*u.Nillable)
	}
	if u.Strings != nil {
		builder.SetStrings(u.Strings)
	}
	if u.Ints != nil {
		builder.SetInts(u.Ints)
	}
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), upserts the entity
// (creating it if it doesn't exist or updating it if it does), and does another query
// (using provided query as base) to get the entity, with all eager loaded edges.
func (u *UpsertCategoryParams) Exec(ctx context.Context, id int, builder *ent.CategoryCreate, query *ent.CategoryQuery, updater *ent.CategoryUpdateOne) (*ent.Category, error) {
	// Set the ID for the upsert operation
	builder.SetID(id)

	// Apply all inputs from the params (fields and M2O edges only; M2M handled separately)
	builder = u.ApplyInputs(builder)

	// Perform upsert with OnConflict - partial update mode (PATCH-like semantics via PUT)
	// Only provided fields are updated; unprovided optional fields retain their existing values
	err := builder.OnConflictColumns(category.FieldID).UpdateNewValues().Exec(ctx)
	if err != nil {
		return nil, err
	}
	if u.Pets != nil {
		// Field was explicitly provided in the request (could be empty array or have values)
		// Always clear first to ensure replace semantics (not append)
		edgeUpdater := updater.ClearPets()
		if len(u.Pets) > 0 {
			// Add the new edge IDs
			edgeUpdater = edgeUpdater.AddPetIDs(u.Pets...)
		}
		// If empty array was provided, just clear (don't add anything)
		err = edgeUpdater.Exec(ctx)
		if err != nil {
			return nil, err
		}
	}

	// Fetch the entity with eager-loaded edges
	return EagerLoadCategory(query.Where(category.ID(id))).Only(ctx)
}

// UpsertUserParams defines parameters for upserting a User via a PUT request.
// Only includes fields/edges not excluded from upsert operations.
// Upsert performs partial updates: only provided fields are updated, unprovided optional fields retain their existing values.
type UpsertUserParams struct {
	// Name of the user.
	Name string `json:"name"`
	// Type of object being defined (user or system which is for internal usecases).
	Type *user.Type `json:"type"`
	// Full name if USER, otherwise null.
	Description *string `json:"description,omitempty"`
	// If the user is still in the source system.
	Enabled *bool `json:"enabled"`
	// Email associated with the user. Note that not all users have an associated email address.
	Email *string `json:"email,omitempty"`
	// Avatar data for the user. This should generally only apply to the USER user type.
	Avatar []byte `json:"avatar,omitempty"`
	// Hashed password for the user, this shouldn't be readable in the spec anywhere.
	PasswordHashed string `json:"password_hashed"`
	// The github user raw JSON data.
	GithubData *github.User `json:"github_data,omitempty"`
	// Any data that is not defined in the schema.
	AnyData             *github.User          `json:"any_data,omitempty"`
	ProfileURL          *schema.ExampleValuer `json:"profile_url,omitempty"`
	LastAuthenticatedAt *time.Time            `json:"last_authenticated_at,omitempty"`
}

func (u *UpsertUserParams) ApplyInputs(builder *ent.UserCreate) *ent.UserCreate {
	builder.SetName(u.Name)
	if u.Type != nil {
		builder.SetType(*u.Type)
	}
	if u.Description != nil {
		builder.SetDescription(*u.Description)
	}
	if u.Enabled != nil {
		builder.SetEnabled(*u.Enabled)
	}
	if u.Email != nil {
		builder.SetEmail(*u.Email)
	}
	if u.Avatar != nil {
		builder.SetAvatar(u.Avatar)
	}
	builder.SetPasswordHashed(u.PasswordHashed)
	if u.GithubData != nil {
		builder.SetGithubData(u.GithubData)
	}
	if u.AnyData != nil {
		builder.SetAnyData(u.AnyData)
	}
	if u.ProfileURL != nil {
		builder.SetProfileURL(u.ProfileURL)
	}
	if u.LastAuthenticatedAt != nil {
		builder.SetLastAuthenticatedAt(*u.LastAuthenticatedAt)
	}
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), upserts the entity
// (creating it if it doesn't exist or updating it if it does), and does another query
// (using provided query as base) to get the entity, with all eager loaded edges.
func (u *UpsertUserParams) Exec(ctx context.Context, id uuid.UUID, builder *ent.UserCreate, query *ent.UserQuery, updater *ent.UserUpdateOne) (*ent.User, error) {
	// Set the ID for the upsert operation
	builder.SetID(id)

	// Apply all inputs from the params (fields and M2O edges only; M2M handled separately)
	builder = u.ApplyInputs(builder)

	// Perform upsert with OnConflict - partial update mode (PATCH-like semantics via PUT)
	// Only provided fields are updated; unprovided optional fields retain their existing values
	err := builder.OnConflictColumns(user.FieldID).UpdateNewValues().Exec(ctx)
	if err != nil {
		return nil, err
	}

	// Fetch the entity with eager-loaded edges
	return EagerLoadUser(query.Where(user.ID(id))).Only(ctx)
}
