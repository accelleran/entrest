{{- /*
  Copyright (c) Accelleran nv. All rights reserved. Use of
  this source code is governed by the MIT license that can be found in
  the LICENSE file.
*/ -}}
{{- define "rest/replace" }}
{{- with extend $ "Package" "rest" }}{{ template "header" . }}{{ end }}

import (
    {{- template "helper/rest/standard-imports" . }}
    {{- template "helper/rest/schema-imports" . }}
)

{{- range $t := $.Nodes }}
    {{- $hasReplace := (($t|getAnnotation).HasOperation $.Annotations.RestConfig "replace") }}
    {{- if or
        (($t|getAnnotation).GetSkip $.Annotations.RestConfig)
        (not $t.ID)
        (not $hasReplace)
    }}
        {{- continue }}
    {{ end }}

    // Replace{{ $t.Name|zsingular }}Params defines parameters for replacing a {{ $t.Name|zsingular }} via a PUT request.
    // Only includes fields/edges not excluded from replace operations.
    // Replace performs full resource replacement: unprovided optional fields are cleared (set to nil).
    type Replace{{ $t.Name|zsingular }}Params struct {
    {{- template "helper/upsert/struct-fields" dict "Type" $t "Operation" "replace" "Config" $.Annotations.RestConfig }}
    }

    func (r *Replace{{ $t.Name|zsingular }}Params) ApplyInputs(builder *ent.{{ $t.Name }}Create) *ent.{{ $t.Name }}Create {
    {{- template "helper/upsert/apply-inputs" dict "Type" $t "Operation" "replace" "Receiver" "r" "Config" $.Annotations.RestConfig }}
    }

    // Exec wraps all logic (mapping all provided values to the builder), replaces the entity
    // (creating it if it doesn't exist or fully replacing it if it does), and does another query
    // (using provided query as base) to get the entity, with all eager loaded edges.
    func (r *Replace{{ $t.Name|zsingular }}Params) Exec(ctx context.Context, id {{ $t.ID.Type }}, builder *ent.{{ $t.Name }}Create, query *ent.{{ $t.Name }}Query, updater *ent.{{ $t.Name }}UpdateOne) (*ent.{{ $t.Name }}, error) {
        // Set the ID for the replace operation
        builder.SetID(id)

        // Apply all inputs from the params
        builder = r.ApplyInputs(builder)

        // Perform replace with OnConflict - full replacement mode (true PUT semantics)
        // Unprovided optional/nullable fields are explicitly cleared
        err := builder.OnConflictColumns({{ $t.Package }}.{{ $t.ID.Constant }}).Update(func(u *ent.{{ $t.Name }}Upsert) {
            {{- range $f := $t.Fields }}
                {{- if or (($f|getAnnotation).GetSkip $.Annotations.RestConfig) $f.Annotations.Rest.ReadOnly }}{{ continue }}{{ end }}
                {{- if $f.Optional }}
            if r.{{ $f.StructField }} != nil {
                    {{- if or (hasPrefix $f.Type.Ident "[]") (hasPrefix $f.Type.Ident "*") $f.IsBytes }}
                u.Set{{ $f.StructField }}(r.{{ $f.StructField }})
                    {{- else }}
                u.Set{{ $f.StructField }}(*r.{{ $f.StructField }})
                    {{- end }}
            } else {
                u.Clear{{ $f.StructField }}()
            }
                {{- else if $f.Nillable }}
            if r.{{ $f.StructField }} != nil {
                u.Set{{ $f.StructField }}(*r.{{ $f.StructField }})
            }
            // Note: Nillable field without Optional cannot be cleared (Ent doesn't generate Clear method)
                {{- else if $f.Default }}
            if r.{{ $f.StructField }} != nil {
                    {{- if or (hasPrefix $f.Type.Ident "[]") (hasPrefix $f.Type.Ident "*") $f.IsBytes }}
                u.Set{{ $f.StructField }}(r.{{ $f.StructField }})
                    {{- else }}
                u.Set{{ $f.StructField }}(*r.{{ $f.StructField }})
                    {{- end }}
            }
                {{- else }}
                    {{- if or (hasPrefix $f.Type.Ident "[]") (hasPrefix $f.Type.Ident "*") $f.IsBytes }}
            u.Set{{ $f.StructField }}(r.{{ $f.StructField }})
                    {{- else }}
            u.Set{{ $f.StructField }}(r.{{ $f.StructField }})
                    {{- end }}
                {{- end }}
            {{- end }}
            {{- range $e := $t.Edges }}
                {{- if or
                    (($e|getAnnotation).GetSkip $.Annotations.RestConfig)
                    $e.Annotations.Rest.ReadOnly
                    (not (edgeHasOperation $e $t $.Annotations.RestConfig "replace"))
                    (not $e.Type.ID)
                }}
                    {{- continue }}
                {{ end -}}
                {{- $f := $e.Field }}
                {{- if $f }}
                    {{- if or (($f|getAnnotation).GetSkip $.Annotations.RestConfig) $f.Annotations.Rest.ReadOnly }}{{ continue }}{{ end }}
                    {{- if or $f.Nillable $f.Optional }}
            if r.{{ $f.StructField }} != nil {
                        {{- if $f.Nillable }}
                u.Set{{ $f.StructField }}(r.{{ $f.StructField }})
                        {{- else }}
                u.Set{{ $f.StructField }}(*r.{{ $f.StructField }})
                        {{- end }}
            } else {
                u.Clear{{ $f.StructField }}()
            }
                    {{- else }}
                        {{- if $f.Nillable }}
            u.Set{{ $f.StructField }}(r.{{ $f.StructField }})
                        {{- else }}
            u.Set{{ $f.StructField }}(*r.{{ $f.StructField }})
                        {{- end }}
                    {{- end }}
                {{- else }}
                    {{- /* Edges without backing fields can't be set in Update callback (Ent doesn't generate setters in Upsert type) */ -}}
                    {{- /* Non-unique edges without backing fields are handled separately after the main upsert (see below) */ -}}
                {{- end }}
            {{- end }}
        }).Exec(ctx)
        if err != nil {
            return nil, err
        }

        {{- range $e := $t.Edges }}
            {{- if or
                (($e|getAnnotation).GetSkip $.Annotations.RestConfig)
                $e.Annotations.Rest.ReadOnly
                (not (edgeHasOperation $e $t $.Annotations.RestConfig "replace"))
                (not $e.Type.ID)
                $e.Unique
                $e.Field
            }}
                {{- continue }}
            {{- end }}
        {
            // Always clear (Replace means full replacement - unprovided fields are cleared)
            edgeUpdater := updater.Clear{{ $e.StructField }}()
            if len(r.{{ $e.StructField }}) > 0 {
                // Add the new edge IDs if provided
                edgeUpdater = edgeUpdater.Add{{ $e.Name|zsingular|pascal }}IDs(r.{{ $e.StructField }}...)
            }
            // If empty array or omitted, just clear (don't add anything)
            err = edgeUpdater.Exec(ctx)
            if err != nil {
                return nil, err
            }
        }
        {{- end }}

        // Fetch the entity with eager-loaded edges
        return EagerLoad{{ $t.Name|zsingular }}(query.Where({{ $t.Package }}.ID(id))).Only(ctx)
    }
{{- end }}{{/* end range */}}
{{- end }}{{/* end template */}}


